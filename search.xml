<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>事务失效的情况</title>
      <link href="/2025/12/14/%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5/"/>
      <url>/2025/12/14/%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>做事务逻辑的时候有几个常见的坑，在开发的时候一定要避免！</p><h2 id="1-非public修饰的方法"><a href="#1-非public修饰的方法" class="headerlink" title="1.非public修饰的方法"></a>1.非public修饰的方法</h2><p>这个比较简单不容易出错。</p><h2 id="2-同一个内的方法调用"><a href="#2-同一个内的方法调用" class="headerlink" title="2.同一个内的方法调用"></a>2.同一个内的方法调用</h2><p>需要注入自身代理对象来调用。</p><h2 id="3-非spring容器管理的bean-或者是new出来的对象"><a href="#3-非spring容器管理的bean-或者是new出来的对象" class="headerlink" title="3.非spring容器管理的bean,或者是new出来的对象"></a>3.非spring容器管理的bean,或者是new出来的对象</h2><p>这个方面也不太容易出错，多注意就行。</p><h2 id="4-异常捕获但未抛出，或抛出非指定的异常"><a href="#4-异常捕获但未抛出，或抛出非指定的异常" class="headerlink" title="4.异常捕获但未抛出，或抛出非指定的异常"></a>4.异常捕获但未抛出，或抛出非指定的异常</h2><p>Spring 事务的回滚逻辑依赖未被捕获的异常：若事务方法内捕获了异常且未重新抛出，事务管理器无法感知异常，会默认提交事务。<br>解决办法：1.抛出指定异常。<br>                  2.配置在Transactional后rollbackFor&#x3D;指定异常。</p><h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><p>日志排查：开启 Spring 事务日志，查看是否有 “Creating transaction”“Rolling back transaction” 日志：</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>事务失效的核心是代理未生效或异常未被感知<br>排查时优先检查：<br>1.方法是否为 public；<br>2.是否同类内部调用；<br>3.类是否被 Spring 管理；<br>4.异常是否被捕获 &#x2F; 抛出类型是否匹配；</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring,事务 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
